#!/bin/bash

# Arch Linux Install Script 
# -------------------------
# author    : prstephens
#             https://github.com/prstephens           
# project   : https://github.com/prstephens/archinstallscript
# license   : LGPL-3.0 (http://opensource.org/licenses/lgpl-3.0.html)
# reference : https://wiki.archlinux.org/index.php/Installation_guide

set -e
set -o pipefail
#set -x #toggle for debug. Will print all commands.

# Globals
BACKTITLE="Arch Installer v3"
BASE_URL="https://raw.githubusercontent.com/prstephens/archinstallscript/master/"
USE_CRYPT=0
USE_RAID=0
TEST=0
MIRROR_COUNTRY=GB

# --------------------------------------------------------

mainmenu(){
        if [ "${1}" = "" ]; then
                nextitem="."
        else
                nextitem=${1}
        fi
        options=()
        options+=("WIPE DEVICE" "(Optional) Securely wipe disk or partition before installation")
        options+=("PARTITION DISK" "Partition disk using cfdisk to create EFI, swap and root partitions")
        options+=("ENCRYPTION" "(Optional) Use full disk enryption and detached header for deniablity")
        options+=("MOUNT" "Select the partitions to mount")
        options+=("SETUP USER" "Setup a user and root password")
        options+=("INSTALL" "Perform Arch Linux base Installation")
        options+=("" "")
        options+=("FINISH" "Finish and reboot")

        sel=$(whiptail --backtitle "${BACKTITLE}" --title "Main Menu" --menu "" --fb --cancel-button "Exit" --default-item "${nextitem}" 0 78 0\
                "${options[@]}" \
                3>&1 1>&2 2>&3)
        if [ "$?" = "0" ]; then
                case ${sel} in
                        "WIPE DEVICE")
                                preparedisk
                                nextitem="PARTITION DISK"
                        ;;
                        "PARTITION DISK")
                                diskpartcfdisk
                                nextitem="ENCRYPTION"
                        ;;
                        "ENCRYPTION")
                                enablelvm
                                nextitem="MOUNT"
                        ;;
                        "MOUNT")
                                choosepartitions
                                nextitem="SETUP USER"
                        ;;
                        "SETUP USER")
                                getuserinfo
                                nextitem="INSTALL"
                        ;;
                        "INSTALL")
                                performinstall
                                configuration
                                installbootloader
                                setupuser
                                finish
                                nextitem="FINISH"
                        ;;
                        "FINISH")
                                rebootpc
                                nextitem="FINISH"
                        ;;
                esac
                mainmenu "${nextitem}"
        else
                clear
        fi
}

preparedisk(){
        wipedevice=$( selectdisk "Choose device to be wiped" )

        if (whiptail --backtitle "${BACKTITLE}" --title "### WARNING ###" --yesno "Are you sure you want to secure wipe ${wipedevice}? \n\nTHIS CANNOT BE UNDONE. ALL DATA WILL BE PERMANENTLY LOST!" --defaultno --fb 0 78) then
		cryptsetup open --type plain -d /dev/urandom ${wipedevice} to_be_wiped
                dd if=/dev/zero of=/dev/mapper/to_be_wiped status=progress || :
                cryptsetup close to_be_wiped
	fi 
}

diskpartcfdisk(){
	device=$( selectdisk "Edit Partitions (cfdisk)" )
        if [ "$?" = "0" ]; then
            clear
            cfdisk ${device}
        fi
}

selectdisk(){
        items=$(lsblk -d -p -n -l -o NAME,SIZE -e 7,11)
        options=()
        IFS_ORIG=$IFS
        IFS=$'\n'
        for item in ${items}
        do  
                options+=("${item}" "")
        done
        IFS=$IFS_ORIG
        result=$(whiptail --backtitle "${BACKTITLE}" --title "${1}" --menu "" --fb 0 78 0 "${options[@]}" 3>&1 1>&2 2>&3)
        if [ "$?" != "0" ]
        then
                return 1
        fi
        echo ${result%%\ *}
        return 0    
}

enablelvm(){
        USE_CRYPT=1
        chooseencryptpartition
        clear
        echo "### CREATING LUKS PARTITION ON ${realrootdev} ____________________"

        # create LUKS encrypted partition with detached header for deniable encryption.
        # The partiton looks like normal random data. No LUKS header describinbg the hash or salt used. 
        # 
        # --offset means we can restore the luks header if need be later on:
        #
        #       cryptsetup luksRestoreHeader /dev/<device> --header-backup-file /path/to/header.img
        #
        # If we want to wipe ALL LUKS header info again then use:
        #
        #       dd if=/dev/urandom of=/dev/<device> bs=512 count=32768

        dd if=/dev/zero of=header.img bs=16M count=1
        chmod 600 header.img
        cryptsetup luksFormat $realrootdev --offset 32768 --header header.img
        cryptsetup open --header header.img $realrootdev cryptlvm

        ROOTUUID=$(blkid -s UUID -o value $realrootdev) # not required but keeping it for debug reasons

        # create the LVM partitons
        pvcreate /dev/mapper/cryptlvm
        vgcreate vg1 /dev/mapper/cryptlvm

        swapspace=$(whiptail --backtitle "$BACKTITLE" --inputbox "Enter SWAP size:" --fb 0 20 3>&1 1>&2 2>&3)

        lvcreate -L ${swapspace}G vg1 -n swap
        lvcreate -l 100%FREE vg1 -n root
}

chooseencryptpartition(){
	itemsinfo=$(lsblk -o NAME,SIZE,FSTYPE)
        items=$(lsblk -p -n -l -o NAME -e 7,11)
        deviceitems=$(lsblk -d -n -l -o NAME -e 7,11)
        options=()
        optionstoremove=()
        IFS_ORIG=$IFS
        IFS=$'\n'
        for item in ${deviceitems}
        do  
                optionstoremove+=("/dev/${item}")
        done
        for item in ${items}
        do  
                if [[ ! " ${optionstoremove[@]} " =~ " ${item} " ]]; then
                        options+=("${item}" "")
                fi
        done

	realrootdev=$(whiptail --backtitle "${BACKTITLE}" --title "Select Root partition to encrypt" --menu "${itemsinfo}" --fb --default-item "${rootdev}" 0 78 0 \
		"${options[@]}" \
		3>&1 1>&2 2>&3)
	if [ ! "$?" = "0" ]; then
		return 1
	fi
	
}

choosepartitions(){
        itemsinfo=$(lsblk -o NAME,SIZE,FSTYPE)
        items=$(lsblk -p -n -l -o NAME -e 7,11)
        deviceitems=$(lsblk -d -n -l -o NAME -e 7,11)
        options=()
        optionstoremove=()
        IFS_ORIG=$IFS
        IFS=$'\n'
        for item in ${deviceitems}
        do  
                optionstoremove+=("/dev/${item}")
        done
        for item in ${items}
        do  
                if [[ ! " ${optionstoremove[@]} " =~ " ${item} " ]]; then
                        options+=("${item}" "")
                fi
        done
      
	bootdev=$(whiptail --backtitle "${BACKTITLE}" --title "Select Boot partition" --menu "${itemsinfo}" --fb --default-item "${bootdev}" 0 78 0 \
		"none" "-" \
		"${options[@]}" \
		3>&1 1>&2 2>&3)
	if [ ! "$?" = "0" ]; then
		return 1
	else
		if [ "${bootdev}" = "none" ]; then
			bootdev=
		fi
	fi

	swapdev=$(whiptail --backtitle "${BACKTITLE}" --title "Select Swap partition" --menu "${itemsinfo}" --fb --default-item "${swapdev}" 0 78 0 \
		"none" "-" \
		"${options[@]}" \
		3>&1 1>&2 2>&3)
	if [ ! "$?" = "0" ]; then
		return 1
	else
		if [ "${swapdev}" = "none" ]; then
			swapdev=
		fi
	fi

        rootdev=$(whiptail --backtitle "${BACKTITLE}" --title "Select Root partition" --menu "${itemsinfo}" --fb --default-item "${rootdev}" 0 78 0 \
                "${options[@]}" \
                3>&1 1>&2 2>&3)
        if [ ! "$?" = "0" ]; then
                return 1
        fi
        
        msg=""
        msg=${msg}"Boot          : "${bootdev}"\n"
        msg=${msg}"Swap          : "${swapdev}"\n"
        msg=${msg}"Root          : "${rootdev}"\n"

        if !(whiptail --backtitle "${BACKTITLE}" --title "Are these values correct?" --fb --yesno "${msg}" 0 78) then
                choosepartitions
        fi      
}

getuserinfo(){
        hostname=$(whiptail --backtitle "$BACKTITLE" --inputbox "Enter hostname:" --fb 0 50 3>&1 1>&2 2>&3)
        user=$(whiptail --backtitle "$BACKTITLE" --inputbox "Enter admin username:" --fb 0 50 3>&1 1>&2 2>&3)

        password="x"
        password2="xx"
        passphrase_invalid_message=""

        while [[ "$password" != "$password2" ]]; do

            password=$(whiptail --backtitle "$BACKTITLE" --passwordbox "${passphrase_invalid_message}Please enter the admin password:" --fb 10 50 3>&1 1>&2 2>&3)
            password2=$(whiptail --backtitle "$BACKTITLE" --passwordbox "Please repeat the admin password:" --fb 10 50 3>&1 1>&2 2>&3)
            passphrase_invalid_message="Passwords do not match! "

        done
        
        msg=${msg}"Hostname      : "${hostname}"\n"
        msg=${msg}"User          : "${user}"\n\n"
}

performinstall(){
        if (whiptail --backtitle "${BACKTITLE}" --title "RAID" --yesno "Is a RAID Array being used?" --defaultno --fb 0 78) then
                USE_RAID=1
                msg=${msg}"Use RAID?     : "${USE_RAID}"\n\n"
	fi

        whiptail --backtitle "${BACKTITLE}" --title "Are these values correct?" --yesno "${msg}" --fb 0 78 3>&1 1>&2 2>&3
        if ([ ! "$?" = "0" ];) then
		mainmenu "1)"
	fi

        if (whiptail --backtitle "${BACKTITLE}" --title "### WARNING ###" --yesno "Do you want to format ${bootdev}? \n\nTHIS COULD ERASE EXISITING OPERATING SYSTEM BOOTLOADERS" --defaultno --fb 0 78) then
		mkfs.fat -F 32 ${bootdev}
	fi
        
        clear

        timedatectl set-ntp true

        # Setup the partitions
        echo "____________________ ### STARTING INSTALL ### ____________________"
        read -p "You are about to wipe ${rootdev}? [y/N]: " wipe
        if [ $wipe = 'y' ]
        then
                wipefs -a $rootdev
                mkfs.btrfs $rootdev
        else
                echo "Install stopped"
                exit
        fi

        if [ ! "${swapdev}" = "" ]
        then
                mkswap $swapdev
                swapon $swapdev
        fi

        #root
        mount $rootdev /mnt

        echo "### Creating BTRFS subvolumes... ____________________"
        btrfs su cr /mnt/@
        btrfs su cr /mnt/@home
        btrfs su cr /mnt/@var_log
        btrfs su cr /mnt/@snapshots
        umount /mnt

        mount -o noatime,commit=120,compress=zstd,space_cache=v2,subvol=@ $rootdev /mnt
        
        # You need to manually create folders to mount the other subvolumes at
        mkdir -p /mnt/{boot/efi,home,var/log,.snapshots}

        mount -o noatime,commit=120,compress=zstd,space_cache=v2,discard=async,subvol=@home $rootdev /mnt/home

        mount -o noatime,commit=120,compress=zstd,space_cache=v2,discard=async,subvol=@var_log $rootdev /mnt/var/log

        mount -o noatime,commit=120,compress=zstd,space_cache=v2,discard=async,subvol=@snapshots $rootdev /mnt/.snapshots

        if [[ "$USE_CRYPT" -eq 1 ]]
        then
                mount $bootdev /mnt/boot

                # copy LUKS header file now 
                mv header.img /mnt/boot
        else   
                mount $bootdev /mnt/boot/efi
        fi

        # determine if we are installing on a laptop or desktop
        # if laptop, install tlp for better power management
        # see here: https://www.dmtf.org/sites/default/files/standards/documents/DSP0134_3.6.0.pdf
        chassis=$(cat /sys/class/dmi/id/chassis_type)
        if exists_in_list "8,9,10" "," ${chassis}
        then
                echo "tlp" >> /tmp/packages 
        fi

        echo "### Installing packages... ____________________"

        if [[ "$TEST" -eq 1 ]]
        then
                pacstrap /mnt $(< /tmp/packages-test)
        else
                pacstrap /mnt $(< /tmp/packages)
        fi

        genfstab -U /mnt >> /mnt/etc/fstab
}

exists_in_list() {
    LIST=$1
    DELIMITER=$2
    VALUE=$3
    [[ "$LIST" =~ ($DELIMITER|^)$VALUE($DELIMITER|$) ]]
}

installbootloader(){
        clear
        echo "### Installing GRUB... ____________________"

        REMOVABLE=""
        if (whiptail --backtitle "${BACKTITLE}" --title "GRUB Bootloader Install" --fb --yesno "Are you installing GRUB to a removable USB device?" --defaultno 0 78) then
                REMOVABLE="--removable"
        fi

        if [[ "$USE_CRYPT" -eq 1 ]]
        then
                bootdir=/boot
                arch-chroot /mnt sed -i "s|^GRUB_CMDLINE_LINUX=.*$|GRUB_CMDLINE_LINUX=\"cryptdevice=$realrootdev:cryptlvm:header root=/dev/vg1/root resume=$swapdev\"|" /etc/default/grub
        else   
                bootdir=/boot/efi
                arch-chroot /mnt sed -i "s|^GRUB_CMDLINE_LINUX=.*$|GRUB_CMDLINE_LINUX=\"resume=$swapdev\"|" /etc/default/grub
        fi
 
        arch-chroot /mnt sed -i 's/^GRUB_GFXMODE=.*$/GRUB_GFXMODE=1920x1080x32/' /etc/default/grub
        arch-chroot /mnt sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*$/GRUB_CMDLINE_LINUX_DEFAULT="quiet loglevel=3 rd.systemd.show_status=false nowatchdog mitigations=off"/' /etc/default/grub
        arch-chroot /mnt sed -i 's/^#GRUB_DISABLE_OS_PROBER=.*$/GRUB_DISABLE_OS_PROBER="false"/' /etc/default/grub
        arch-chroot /mnt os-prober
        arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=$bootdir --bootloader-id=GRUB --recheck $REMOVABLE
        arch-chroot /mnt grub-mkconfig -o /boot/grub/grub.cfg
}

configuration(){
        clear
        echo "### Configuring system... ____________________"

        # Set Cloudfare as our DNS
        cat <<EOT > /mnt/etc/resolv.conf
options timeout:1
options single-request

nameserver 1.1.1.1
nameserver 1.0.0.1
nameserver 8.8.8.8
EOT

        chattr +i /mnt/etc/resolv.conf

        cat <<EOT >> /mnt/etc/NetworkManager/NetworkManager.conf
[main]
dns=none
systemd-resolved=false
EOT

        cat <<EOT >> /mnt/etc/hosts
127.0.0.1	localhost
::1		localhost
192.168.1.192   rainbowdash.localdomain rainbowdash
192.168.1.66    libreelec.localdomain libreelec
EOT

        echo "Updating pacman mirrors to awesomeness..."
        # Update pacman mirror list
        arch-chroot /mnt reflector --verbose -c $MIRROR_COUNTRY -l 25 --age 12 -p https --sort rate --save /etc/pacman.d/mirrorlist

        echo "Setting up spacetime continuum..."
        # Set date time
        arch-chroot /mnt ln -sf /usr/share/zoneinfo/Europe/London /etc/localtime
        arch-chroot /mnt hwclock --systohc

        # Set locale to en_US.UTF-8 UTF-8
        arch-chroot /mnt sed -i '/en_GB.UTF-8 UTF-8/s/^#//g' /etc/locale.gen
        arch-chroot /mnt locale-gen
        echo "LANG=en_GB.UTF-8" >> /mnt/etc/locale.conf

        # Set the console keymap
        echo "KEYMAP=uk" >> /mnt/etc/vconsole.conf

        # Set hostname
        echo "${hostname}" > /mnt/etc/hostname
        echo "127.0.1.1 ${hostname}.localdomain  ${hostname}" >> /mnt/etc/hosts

        # Set keyboard FN keys to act normal!
        echo "options hid_apple fnmode=2" > /mnt/etc/modprobe.d/hid_apple.conf
        
        # nano syntax highlighting
        echo "include /usr/share/nano/*.nanorc" >> /mnt/etc/nanorc

        cat <<EOT > /etc/profile.d/shell-timeout.sh
TMOUT="\$(( 60*30 ))";
[ -z "\$DISPLAY" ] && export TMOUT;
case \$( /usr/bin/tty ) in
	/dev/tty[0-9]*) export TMOUT;;
esac
EOT

        # performance and secuirty tweaks
        cat <<EOT > /mnt/etc/sysctl.d/99-performance.conf
        # The swappiness sysctl parameter represents the kernel's preference (or avoidance) of swap space. Swappiness can have a value between 0 and 100, the default value is 60. 
# A low value causes the kernel to avoid swapping, a higher value causes the kernel to try to use swap space. Using a low value on sufficient memory is known to improve responsiveness on many systems.
vm.swappiness=10

# The value controls the tendency of the kernel to reclaim the memory which is used for caching of directory and inode objects (VFS cache). 
# Lowering it from the default value of 100 makes the kernel less inclined to reclaim VFS cache (do not set it to 0, this may produce out-of-memory conditions)
vm.vfs_cache_pressure=50

# This action will speed up your boot and shutdown, because one less module is loaded. Additionally disabling watchdog timers increases performance and lowers power consumption
# Disable NMI watchdog
kernel.nmi_watchdog = 0

# Contains, as a percentage of total available memory that contains free pages and reclaimable
# pages, the number of pages at which a process which is generating disk writes will itself start
# writing out dirty data (Default is 20).
vm.dirty_ratio = 5

# Contains, as a percentage of total available memory that contains free pages and reclaimable
# pages, the number of pages at which the background kernel flusher threads will start writing out
# dirty data (Default is 10).
vm.dirty_background_ratio = 5

# This tunable is used to define when dirty data is old enough to be eligible for writeout by the
# kernel flusher threads.  It is expressed in 100'ths of a second.  Data which has been dirty
# in-memory for longer than this interval will be written out next time a flusher thread wakes up
# (Default is 3000).
#vm.dirty_expire_centisecs = 3000

# The kernel flusher threads will periodically wake up and write old data out to disk.  This
# tunable expresses the interval between those wakeups, in 100'ths of a second (Default is 500).
vm.dirty_writeback_centisecs = 1500

# Enable the sysctl setting kernel.unprivileged_userns_clone to allow normal users to run unprivileged containers.
kernel.unprivileged_userns_clone=1

# To hide any kernel messages from the console
kernel.printk = 3 3 3 3

# Restricting access to kernel logs
kernel.dmesg_restrict = 1

# Restricting access to kernel pointers in the proc filesystem
kernel.kptr_restrict = 2

# Disable Kexec, which allows replacing the current running kernel. 
kernel.kexec_load_disabled = 1

# Increasing the size of the receive queue.
# The received frames will be stored in this queue after taking them from the ring buffer on the network card.
# Increasing this value for high speed cards may help prevent losing packets: 
net.core.netdev_max_backlog = 16384

# Increase the maximum connections
#The upper limit on how many connections the kernel will accept (default 128): 
net.core.somaxconn = 8192

# Increase the memory dedicated to the network interfaces
# The default the Linux network stack is not configured for high speed large file transfer across WAN links (i.e. handle more network packets) and setting the correct values may save memory resources: 
net.core.rmem_default = 1048576
net.core.rmem_max = 16777216
net.core.wmem_default = 1048576
net.core.wmem_max = 16777216
net.core.optmem_max = 65536
net.ipv4.tcp_rmem = 4096 1048576 2097152
net.ipv4.tcp_wmem = 4096 65536 16777216
net.ipv4.udp_rmem_min = 8192
net.ipv4.udp_wmem_min = 8192

# Enable TCP Fast Open
# TCP Fast Open is an extension to the transmission control protocol (TCP) that helps reduce network latency
# by enabling data to be exchanged during the sender's initial TCP SYN [3]. 
# Using the value 3 instead of the default 1 allows TCP Fast Open for both incoming and outgoing connections: 
net.ipv4.tcp_fastopen = 3

# Enable BBR
# The BBR congestion control algorithm can help achieve higher bandwidths and lower latencies for internet traffic
net.core.default_qdisc = cake
net.ipv4.tcp_congestion_control = bbr

# TCP SYN cookie protection
# Helps protect against SYN flood attacks. Only kicks in when net.ipv4.tcp_max_syn_backlog is reached: 
net.ipv4.tcp_syncookies = 1

# Protect against tcp time-wait assassination hazards, drop RST packets for sockets in the time-wait state. Not widely supported outside of Linux, but conforms to RFC: 
net.ipv4.tcp_rfc1337 = 1

# By enabling reverse path filtering, the kernel will do source validation of the packets received from all the interfaces on the machine. This can protect from attackers that are using IP spoofing methods to do harm. 
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.rp_filter = 1

# Disable ICMP redirects
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv6.conf.default.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# To use the new FQ-PIE Queue Discipline (>= Linux 5.6) in systems with systemd (>= 217), will need to replace the default fq_codel. 
net.core.default_qdisc = fq_pie
EOT

        echo "tcp_bbr" > /mnt/etc/modules-load.d/bbr.conf

        # Create the pacman mirrorlist updater service
        cat <<EOT > /mnt/etc/systemd/system/reflector.service
[Unit]
Description=Pacman mirrorlist update
Wants=network-online.target
After=network-online.target nss-lookup.target
[Service]
Type=oneshot
ExecStart=/usr/bin/reflector -c GB -l 25 --age 12 -p https --sort rate --save /etc/pacman.d/mirrorlist
[Install]
WantedBy=multi-user.target
EOT

        cat <<EOT > /mnt/etc/modprobe.d/blacklist.conf
blacklist iTCO_wdt
blacklist pcspkr
blacklist joydev
blacklist mousedev
blacklist mac_hid
blacklist uvcvideo
blacklist xpad
blacklist nvidiafb
blacklist nouveau
EOT
        # for 11th cpu or lower
        cat <<EOT > /mnt/etc/modprobe.d/i915.conf
options i915 enable_guc=2
EOT

        cat << EOT > /mnt/etc/udev/rules.d/60-ioschedulers.rules
# set scheduler for NVMe
ACTION=="add|change", KERNEL=="nvme[0-9]*", ATTR{queue/scheduler}="none"
# set scheduler for SSD and eMMC
ACTION=="add|change", KERNEL=="sd[a-z]|mmcblk[0-9]*", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="mq-deadline"
# set scheduler for rotating disks
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", ATTR{queue/scheduler}="bfq"
EOT

        # PulseAudio
        arch-chroot /mnt sed -i '/load-module module-suspend-on-idle/ s/^#*/#/' /etc/pulse/default.pa

        # add btrfs to modules
        sed -i 's/^MODULES=.*$/MODULES=(i915 btrfs)/' /mnt/etc/mkinitcpio.conf

        if [[ "$USE_CRYPT" -eq 1 ]]
        then
                # generate key file
                dd bs=512 count=4 if=/dev/random of=/mnt/crypto_keyfile.bin iflag=fullblock
                chmod 600 /mnt/crypto_keyfile.bin
                cryptsetup luksAddKey $realrootdev --header /mnt/boot/header.img /mnt/crypto_keyfile.bin
                sed -i 's/^MODULES=.*$/MODULES=(i915 btrfs loop)/' /mnt/etc/mkinitcpio.conf
                sed -i 's/^FILES=.*$/FILES=(\/crypto_keyfile.bin \/boot\/header.img)/' /mnt/etc/mkinitcpio.conf

                # get the modified encrypt hook
                arch-chroot /mnt curl -sL $BASE_URL/configs/encrypt-dh -o /etc/initcpio/hooks/encrypt-dh
                arch-chroot /mnt cp /usr/lib/initcpio/install/encrypt /etc/initcpio/install/encrypt-dh
        fi

        if [[ "$USE_RAID" -eq 1 ]]
        then
                mdadm --detail --scan >> /mnt/etc/mdadm.conf
                sed -i 's/^BINARIES=.*$/BINARIES=(mdmon)/' /mnt/etc/mkinitcpio.conf
                sed -i 's/^HOOKS=.*$/HOOKS=(base udev autodetect keyboard keymap consolefont modconf block mdadm_udev filesystems resume fsck)/' /mnt/etc/mkinitcpio.conf

                if [[ "$USE_CRYPT" -eq 1 ]]
                then
                        sed -i 's/^HOOKS=.*$/HOOKS=(base udev autodetect keyboard keymap consolefont modconf block mdadm_udev encrypt-dh lvm2 filesystems resume fsck)/' /mnt/etc/mkinitcpio.conf
                fi
        else
                if [[ "$USE_CRYPT" -eq 1 ]]
                then
                        sed -i 's/^HOOKS=.*$/HOOKS=(base udev autodetect keyboard keymap consolefont modconf block encrypt-dh lvm2 filesystems resume fsck)/' /mnt/etc/mkinitcpio.conf
                else
                        sed -i 's/^HOOKS=.*$/HOOKS=(base udev autodetect keyboard keymap consolefont modconf block filesystems resume fsck)/' /mnt/etc/mkinitcpio.conf
                fi
        fi

        # Bluetooth config
        arch-chroot /mnt sed -i 's/^#DiscoverableTimeout = 0/DiscoverableTimeout = 0/' /etc/bluetooth/main.conf
        arch-chroot /mnt sed -i 's/^#AutoEnable=true/AutoEnable=true/' /etc/bluetooth/main.conf
        arch-chroot /mnt sed -i 's/^#FastConnectable=.*$/FastConnectable=true/' /etc/bluetooth/main.conf
        arch-chroot /mnt sed -i 's/^#ReconnectIntervals=.*$/ReconnectIntervals=5/' /etc/bluetooth/main.conf

        # BBC Micro console font :)
        arch-chroot /mnt curl -sL $BASE_URL/fonts/acorn/console/bedstead-10.psf.gz -o /usr/share/kbd/consolefonts/bedstead-10.psf.gz
        arch-chroot /mnt curl -sL $BASE_URL/fonts/acorn/console/bedstead-20.psf.gz -o /usr/share/kbd/consolefonts/bedstead-20.psf.gz
        arch-chroot /mnt curl -sL $BASE_URL/fonts/acorn/console/acorn.psf.gz -o /usr/share/kbd/consolefonts/acorn.psf.gz
        echo "FONT=bedstead-20" >> /mnt/etc/vconsole.conf

        # ### Make the Boot files ###
        arch-chroot /mnt mkinitcpio -P

        # Enable services
        echo "Enabling services..."
        arch-chroot /mnt systemctl enable NetworkManager.service
        arch-chroot /mnt systemctl enable bluetooth.service
        arch-chroot /mnt systemctl enable cups.service
        arch-chroot /mnt systemctl enable reflector.timer
        arch-chroot /mnt systemctl enable fstrim.timer
        arch-chroot /mnt systemctl enable sshd

        if [[ "$USE_CRYPT" -eq 1 ]]
        then
                arch-chroot /mnt systemctl enable lvm2-monitor
        else
                arch-chroot /mnt systemctl mask lvm2-monitor
        fi

        arch-chroot /mnt systemctl mask systemd-random-seed
}

setupuser(){
        clear
        echo "### Setting up user... ____________________"

        arch-chroot /mnt useradd -m -G wheel $user
        arch-chroot /mnt sed -i 's/# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /etc/sudoers
        echo "Defaults insults" >> /mnt/etc/sudoers
        echo "${user} ALL=(ALL) NOPASSWD: /usr/bin/mount" >> /mnt/etc/sudoers
        echo "${user} ALL=(ALL) NOPASSWD: /usr/bin/umount" >> /mnt/etc/sudoers
        echo "${user} ALL=(ALL) NOPASSWD: /usr/bin/sed" >> /mnt/etc/sudoers

        # Set root password
        echo "Setting user and root password..."
        echo "${user}:${password}" | arch-chroot /mnt chpasswd
        echo "root:${password}" | arch-chroot /mnt chpasswd

        # config files
        echo "Getting some config files..."
        arch-chroot /mnt curl -sL $BASE_URL/configs/.Xresources -o /home/$user/.Xresources
        arch-chroot /mnt curl -sL $BASE_URL/configs/.bashrc -o /home/$user/.bashrc

        # add a dummy file to let bashrc know to run post-install on first login
        arch-chroot /mnt touch /home/$user/newbie

        # awesome tty login
        arch-chroot /mnt curl -sL $BASE_URL/configs/issue -o /etc/issue

        # set custom pacman.conf 
        arch-chroot /mnt mv /etc/pacman.conf /etc/pacman.conf.bak
        arch-chroot /mnt curl -sL $BASE_URL/configs/pacman.conf -o /etc/pacman.conf
        
        # Copy post-install file to /home/$user
        echo "Copy post-install file to /home/${user}..."
        arch-chroot /mnt curl -sL $BASE_URL/post-install -o /home/$user/post-install
        arch-chroot /mnt sed -i "s|^rootdev=.*$|rootdev=${rootdev}|" /home/$user/post-install
        arch-chroot /mnt sed -i "s|^USE_CRYPT=.*$|USE_CRYPT=${USE_CRYPT}|" /home/$user/post-install
        arch-chroot /mnt sed -i "s|^USE_RAID=.*$|USE_RAID=${USE_RAID}|" /home/$user/post-install
        arch-chroot /mnt chmod a+x /home/$user/post-install

        # Add shell-option to ~/.inputrc to enable case-insensitive tab completion
        if [ ! -a /mnt/home/$user/.inputrc ]; then echo '$include /etc/inputrc' > /mnt/home/$user/.inputrc; fi
        echo 'set completion-ignore-case On' >> /mnt/home/$user/.inputrc

        # own that stuff!
        arch-chroot /mnt chown -R $user:$user /home/$user/
}

rebootpc(){
        if (whiptail --backtitle "${BACKTITLE}" --yesno "Reboot?" --defaultno --fb 0 78) then
                clear
                umount -a
                reboot
        fi
}

finish(){
        whiptail --backtitle "$BACKTITLE" --msgbox --title "Congratulations" "Install Complete\n\nReturn to main menu and select 'Finsh and Reboot'" --fb 0 78
}

# --------------------------------------------------------

checkconnection(){
        if [[ $(ping -q -w1 -c1 google.com &>/dev/null && echo online || echo offline) == "offline" ]]; 
            then
                whiptail --backtitle "$BACKTITLE" --msgbox --title "No Network Connection" "You need to be connected to the Internet.\n\nInstallation stopped." --fb 0 78
                exit
        fi
}

updatemirrors(){
        MIRROR_COUNTRY=$(echo $MIRROR_COUNTRY | tr '[:lower:]' '[:upper:]')
        reflector --verbose -c $MIRROR_COUNTRY -l 25 --age 12 -p https --sort rate --save /etc/pacman.d/mirrorlist
}

dependencies(){
        pacman -Sy --noconfirm archlinux-keyring
}

getpackagelist(){
        curl -sL $BASE_URL/packages -o /tmp/packages
        curl -sL $BASE_URL/packages-test -o /tmp/packages-test
}

initialise(){
        checkconnection
        dependencies
        updatemirrors
        getpackagelist

        sed -i '/ParallelDownloads/s/^[#[:space:]]*//g' /etc/pacman.conf
        sed -i '/Color/s/^[#[:space:]]*//g' /etc/pacman.conf
        echo "ILoveCandy" >> /etc/pacman.conf
}

# --------------------------------------------------------

while [[ $# -gt 0 ]]; do
        case "${1}" in
                -t)
                        TEST=1; shift ;;
                -c)
                        umount -A /mnt/boot 
                        umount -A /mnt; shift ;;
                -m)
                        MIRROR_COUNTRY="${2}" && shift 2 || shift ;;
                *)
                        echo "ERROR: Unrecognized installation option '${1}'."; shift 2 ;;
        esac
done

[[ ! -f /tmp/packages ]] && initialise

mainmenu